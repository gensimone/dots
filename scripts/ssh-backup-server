#!/bin/python

import shutil
import sys
import os
import getpass
from argparse import ArgumentParser, REMAINDER, Action
from paramiko import Transport
from paramiko.sftp_client import SFTPClient
from paramiko.ssh_exception import AuthenticationException


class PartitionedValues(Action):
    def __init__(self, *args, delim="+++", **kwargs):
        super().__init__(*args, **kwargs)
        self.delim = delim

    def __call__(
            self, 
            parser,
            namespace,
            values,
            option_string = ''
    ):
        files = namespace.localpaths = []
        namespace.remotepaths = []
        if values:
            for f in values:
                if f == self.delim:
                    files = namespace.remotepaths
                else:
                    files.append(f)


def get_parser() -> ArgumentParser:
    parser = ArgumentParser(
        prog='sftpy',
        description='',
        usage='',
        argument_default=None
    )
    parser.add_argument(
        '-H',
        '--hostname',
        required=True,
        type=str
    )
    parser.add_argument(
        '-p',
        '--port',
        required=False,
        default=22,
        type=int,
    )
    parser.add_argument(
        '-u',
        '--username',
        required=False,
        default='root',
        type=str
    )
    parser.add_argument(
        'paths',
        action=PartitionedValues,
        nargs=REMAINDER,
        type=str
    )
    return parser


def get_sftp_client(hostname: str, port: int, username: str) -> SFTPClient | None:
    transport = Transport((hostname, port))
    try:
        transport.connect(username=username, password=getpass.getpass())
    except AuthenticationException:
        print(f'Invalid password')
        return get_sftp_client(
            hostname=hostname,
            port=port,
            username=username
        )
    return SFTPClient.from_transport(transport)


def display_progress_bar(
        bytes_received: int,
        filesize: int,
        localpath: str,
        remotepath: str,
        ch1: str = "#",
        ch2: str = "-",
        scale: float = 0.55
) -> None:
    columns = shutil.get_terminal_size().columns
    max_width = int(columns * scale)
    filled = int(round(max_width * bytes_received / float(filesize)))
    remaining = max_width - filled
    progress_bar = ch1 * filled + ch2 * remaining
    percent = round(100.0 * bytes_received / float(filesize), 1)

    distance_from_bar = columns - (max_width + 9)  # len bar + percentage len
    title = f"{localpath} "

    if len(title) > distance_from_bar:
        title = f"{title[:distance_from_bar - 4]}... "
    else:
        title = f"{title}{' ' * (distance_from_bar - len(title))}"

    text = f"{title}[{progress_bar}] {percent}%\r"

    sys.stdout.write(text)
    sys.stdout.flush()



def expand_filename(filename: str) -> str:
    return f'{os.path.expanduser('~')}{filename[1:]}' if filename.startswith('~') else filename

def put(
        sftp: SFTPClient,
        localpath: str,
        remotepath: str,
) -> None:
    localpath = expand_filename(localpath)
    if not os.path.exists(localpath):
        raise FileNotFoundError(f'File {localpath} does not exist')

    def _recursive_put(
            localpath: str,
            remotepath: str
    ) -> None:
        basename = os.path.basename(localpath)
        remotepath = f'{remotepath}/{basename}'

        # directory case
        if os.path.isdir(localpath):

            try:
                sftp.mkdir(remotepath)
            except OSError:
                pass

            for file in os.listdir(localpath):
                _recursive_put(
                    localpath=f'{localpath}/{file}',
                    remotepath=remotepath
                )

        # file case
        else:
            sftp.put(
                localpath=localpath,
                remotepath=remotepath,
                callback=lambda bytes_received, filesize: display_progress_bar(
                    bytes_received=bytes_received,
                    filesize=filesize,
                    localpath=localpath,
                    remotepath=remotepath
                )
            )
            print()

    _recursive_put(
        localpath=localpath,
        remotepath=remotepath
    )


if __name__ == '__main__':
    parser = get_parser()
    args = parser.parse_args()
    hostname = args.hostname
    port = args.port
    username = args.username
    remotepaths = args.remotepaths
    localpaths = args.localpaths

    if not localpaths:
        print('Provide at least one file to transfer')
        sys.exit(1)

    sftp_client = get_sftp_client(
        hostname=hostname,
        port=port,
        username=username
    )

    if not sftp_client:
        raise RuntimeError('No SFTPClient object obtained')

    # Transfer ops
    for localpath in localpaths:
        for remotepath in args.remotepaths:
            print(f':: Root path: {remotepath}')
            put(
                sftp=sftp_client,
                localpath=localpath,
                remotepath=remotepath
            )
            print()
    sftp_client.close()
